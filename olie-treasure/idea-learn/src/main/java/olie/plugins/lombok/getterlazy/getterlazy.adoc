= @EqualsAndHashCode

[red]#Laziness is a virtue.懒作是美德#

([red]#getter方法只会被调用一次，而且调用结果会被缓存#)You can let lombok generate a getter which will calculate a value once, the first time this getter is called, and cache it from then on.
([red]#当一个属性的初始化是很浪费资源的时候#)This can be useful if calculating the value takes a lot of CPU, or the value takes a lot of memory.
([red]#使用 lazy=true 特性时需要满足:属性必须是 private 和 final ,并且在声明处进行初始化复制#)To use this feature, create a private final variable, initialize it with the expression that's expensive to run,
and annotate your field with @Getter(lazy=true).
([red]#目标属性的定义不会出现的修改后的中间源码中#)The field will be hidden from the rest of your code, and the expression will be evaluated no more than once,
when the getter is first called. There are no magic marker values (i.e. even if the result of your expensive calculation is null, the result is cached)
and your expensive calculation need not be thread-safe, as lombok takes care of locking.

NOTE: lombok source
----
import lombok.Getter;

public class GetterLazyExample {
  @Getter(lazy=true) private final double[] cached = expensive();

  private double[] expensive() {
    double[] result = new double[1000000];
    for (int i = 0; i < result.length; i++) {
      result[i] = Math.asin(i);
    }
    return result;
  }
}
----

NOTE: compiler source
----
public class GetterLazyExample {
  private final java.util.concurrent.AtomicReference<java.lang.Object> cached = new java.util.concurrent.AtomicReference<java.lang.Object>();

  public double[] getCached() {
    java.lang.Object value = this.cached.get();
    if (value == null) {
      synchronized(this.cached) {
        value = this.cached.get();
        if (value == null) {
          final double[] actualValue = expensive();
          value = actualValue == null ? this.cached : actualValue;
          this.cached.set(value);
        }
      }
    }
    return (double[])(value == this.cached ? null : value);
  }

  private double[] expensive() {
    double[] result = new double[1000000];
    for (int i = 0; i < result.length; i++) {
      result[i] = Math.asin(i);
    }
    return result;
  }
}
----

= Small print
You should never refer to the field directly, always use the getter generated by lombok, because the type of the field will
be mangled into an AtomicReference ([red]#不要在使用被 lazy=true 标记的属性了，因为class 文件中已经没有这个属性喽#).
Do not try to directly access this AtomicReference ([red]#也不要直接引用 AtomicReference 因为它表达的意思可以会在之后的版本中发生变化#); if it points to itself,
the value has been calculated, and it is null. If the reference points to null, then the value has not been calculated.
This behaviour may change in future versions. Therefore, always use the generated getter to access your field!

Other Lombok annotations such as @ToString always call the getter even if you use doNotUseGetters=true.